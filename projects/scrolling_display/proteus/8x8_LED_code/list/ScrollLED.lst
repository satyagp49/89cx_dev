C51 COMPILER V9.02   SCROLLLED                                                             12/05/2016 15:29:46 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE SCROLLLED
OBJECT MODULE PLACED IN .\obj's\ScrollLED.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ScrollLED.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\list\ScrollLED.lst) OBJ
                    -ECT(.\obj's\ScrollLED.obj)

line level    source

   1          #include <REG51.H>
   2          #include <string.h>
   3          #include <lookup_table.h>
   4          
   5          sbit Serial_Data = P1^1;
   6          sbit SH_Clk = P1^0;
   7          sbit ST_Clk = P1^2;
   8          sbit CD4017_Clk = P3^0;
   9          sbit CD4017_Rst = P3^1;
  10          
  11          void delay_ms(unsigned int x)    // delays x msec (at fosc=11.0592MHz)
  12          {
  13   1              unsigned char j=0;
  14   1              while(x-- > 0)
  15   1              {
  16   2                      for (j=0; j<125; j++){;}
  17   2              }
  18   1      }
  19           
  20          void send_data(DISPLAY_WIDTH temp){
  21   1          unsigned int t, Flag;
  22   1          for (t=0; t<LED_DISPLAY_WIDTH; t++){
  23   2              Flag = ((temp.width >> t) & 0x01);
  24   2              if(Flag==0) Serial_Data = 0;
  25   2              else Serial_Data = 1;
  26   2              SH_Clk = 1;
  27   2              SH_Clk = 0;
  28   2          }
  29   1          // Apply clock on ST_Clk
  30   1          ST_Clk = 1;
  31   1          ST_Clk = 0;  
  32   1      }
  33          
  34          DISPLAY_WIDTH DisplayBuffer [LED_DISPLAY_HIEGHT] [LED_DISPLAY_DIGITS] = {{0x00}};
  35          unsigned int speed;
  36          short  l, k, m, ShiftAmount, scroll, temp, shift_step=1, StringLength;
  37          char message[]="ABCD123";
  38          char index_data;
  39          void main() {
  40   1          unsigned char select_line = 0x00, count, shift;
  41   1          unsigned int backup;
  42   1          StringLength = strlen(message) ;
  43   1          do {
  44   2              for (k=0; k<StringLength; k++){
  45   3                  for (scroll=0; scroll<(LED_DISPLAY_WIDTH/shift_step); scroll++) {
  46   4                      for (ShiftAmount=0; ShiftAmount<LED_DISPLAY_HIEGHT; ShiftAmount++){
  47   5                          index_data = message[k];
  48   5                          temp = CharData[index_data][ShiftAmount];
  49   5                          if (LED_DISPLAY_DIGITS > 1) {
  50   6                              for (shift = 0x00; shift<shift_step;shift++) {
  51   7                                  for (count = 0; count < (LED_DISPLAY_DIGITS - 1);count ++) {
  52   8                                      if (count == 0x00) {
  53   9                                          DisplayBuffer [ShiftAmount][count].width >>= 1;
  54   9                                      }
C51 COMPILER V9.02   SCROLLLED                                                             12/05/2016 15:29:46 PAGE 2   

  55   8                                      else {
  56   9                                          backup = DisplayBuffer [ShiftAmount][count].width & 0x01;
  57   9                                          DisplayBuffer [ShiftAmount][count].width >>= 1;
  58   9                                          DisplayBuffer [ShiftAmount][count - 1].width = DisplayBuffer [ShiftAmo
             -unt][count - 1].width | (backup << 7);            
  59   9                                      }
  60   8                                  }
  61   7                              }
  62   6                              backup = DisplayBuffer [ShiftAmount][count].width & 0x01;
  63   6                              DisplayBuffer [ShiftAmount][count - 1].width = DisplayBuffer [ShiftAmount][count -
             - 1].width | (backup << 7);            
  64   6                          }
  65   5                          
  66   5                          DisplayBuffer [ShiftAmount][LED_DISPLAY_DIGITS - 1].width = (DisplayBuffer[ShiftAmount
             -][LED_DISPLAY_DIGITS - 1].width >> shift_step) | (temp << ((LED_DISPLAY_WIDTH -1) - (scroll*shift_step)));
  67   5                     }
  68   4      
  69   4                      speed = 1;
  70   4      #if 0                
                              for(l=0; l<speed;l++){
                                  for (count=0; count<LED_DISPLAY_HIEGHT; count++) {
                                      for (m = 0x00; m < LED_DISPLAY_DIGITS; m++) {
                                          send_data(DisplayBuffer[count][m]);
                                      }
                                      select_line = (0xFF & ~(0x01 << count));
                                      P3 = select_line;
                                      delay_ms(10);
                                  }
                              }
              #else                    
  82   4                      for(l=0; l<speed;l++){
  83   5                          for (count=0; count<LED_DISPLAY_HIEGHT; count++) {
  84   6                              for (m = 0x00; m < LED_DISPLAY_DIGITS; m++) {
  85   7                                  send_data(DisplayBuffer[count][m]);
  86   7                                  CD4017_Clk = 1;
  87   7                                  CD4017_Clk = 0;
  88   7                                  delay_ms(1);
  89   7                              }
  90   6                              CD4017_Rst = 1;
  91   6                              CD4017_Rst = 0;
  92   6                          }
  93   5                      }
  94   4      #endif
  95   4                              
  96   4                              } // scroll
  97   3                      } // k
  98   2              } while(1);
  99   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    646    ----
   CONSTANT SIZE    =   2048    ----
   XDATA SIZE       =     43       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
